type TransferResult = 
 variant {
   Err: TransferError;
   Ok: BlockIndex;
 };
type TransferError = 
 variant {
   BadFee: record {expected_fee: Tokens;};
   InsufficientFunds: record {balance: Tokens;};
   TxCreatedInFuture;
   TxDuplicate: record {duplicate_of: BlockIndex;};
   TxTooOld: record {allowed_window_nanos: nat64;};
 };
type Tokens = record {e8s: nat64;};
type TagUid = nat64;
type TagParam = 
 record {
   cmac: blob;
   ctr: blob;
   uid: blob;
 };
type TagEncodeResult = 
 record {
   key: AESKey;
   transfer_code: AESKey;
 };
type TagCtr = nat32;
type ScanResult = 
 variant {
   Err: ScanError;
   Ok: ScanResponse;
 };
type ScanResponse = 
 record {
   locked: bool;
   owner: bool;
   transfer_code: opt AESKey;
   wallet: blob;
 };
type ScanError = record {msg: text;};
type Scan = 
 record {
   cmac: CMAC;
   ctr: TagCtr;
   transfer_code: AESKey;
   uid: TagUid;
 };
type SDM = 
 service {
   decrypt: (TagParam) -> (vec nat8) query;
   encrypt: (TagParam) -> (blob) query;
   getRegistry: () -> (vec record {
                             TagUid;
                             principal;
                           }) query;
   importScans: (TagUid, vec Hex) -> () oneway;
   isAdmin: () -> (bool);
   postMessage: (NewMessage) -> (vec LoggedMessage);
   reflect: (TagParam) -> (TagParam) query;
   registerTag: (TagUid) -> (TagEncodeResult);
   scan: (Scan) -> (ScanResult);
   show_key: () -> (vec nat8) query;
   tagBalance: (TagUid) -> (nat64);
   text_to_array: (TagParam) -> (vec nat8) query;
   whoami: () -> (principal) query;
   withdraw: (TagUid, vec nat8, nat64) -> (TransferResult);
 };
type NewMessage = 
 record {
   location: opt Location;
   message: text;
   uid: TagUid;
 };
type LoggedMessage = 
 record {
   balance: nat64;
   from: principal;
   location: text;
   message: text;
   time: nat64;
   uid: TagUid;
 };
type Location = 
 record {
   latitude: float64;
   longitude: float64;
 };
type Hex = text;
type CMAC = text;
type BlockIndex = nat64;
type AESKey = text;
service : () -> SDM
